package code;import java.util.*;/** Sources (link): https://www.geeksforgeeks.org/implementing-our-own-hash-table-with-separate-chaining-in-java/ https://opendsa-server.cs.vt.edu/ODSA/Books/CS3/html/HashIntro.html https://www.geeksforgeeks.org/inverted-index/ https://nlp.stanford.edu/IR-book/html/htmledition/a-first-take-at-building-an-inverted-index-1.html **/public class HashMap {    // each linked list in the bucket    private static class Node {        String key;        List<Integer> value;        Node next;        Node(String key) {            this.key = key;            this.value = new ArrayList<>();            this.next = null;        }    }    private static final int DEFAULT_CAPACITY = 1024;    private static final float DEFAULT_LOAD_FACTOR = 0.75f;    private Node[] buckets;    private static int size;    private final float loadFactor;    // constructs empty hashmap    public HashMap() {        this.buckets = new Node[DEFAULT_CAPACITY];        this.size = 0;        this.loadFactor = DEFAULT_LOAD_FACTOR;    }    // size / key to value mappings    public int size() {        return size;    }    // if map has no key to value mappings (empty), return true    public boolean isEmpty() {        return size == 0;    }    // returns hash code, then calculates index in the bucket array    private int hash(String key) {        if (key == null) {            return 0;        }        int hash = 0;        /** https://opendsa-server.cs.vt.edu/ODSA/Books/CS3/html/HashFuncExamp.html **/        for (int i = 0; i < key.length(); i++) {            hash = hash * 13 + key.charAt(i); // prime number 31 para maayos distribution        }        return Math.abs(hash) % buckets.length;    }    /**     * add document ID (value) to the list     * if the word is not in the map, add new entry     *     * @param word the word to index     * @param docId the document ID where the word appears     */    public void addWordOccurrence(String word, int docId) {        // pang normalize ng words, para di madoble        if (word == null) {            word = null; // keep it null        } else {            word = word.toLowerCase().trim();        }        // resize if it's bigger than loadFactor * length of array/buckets        if (size >= loadFactor * buckets.length) {            resize();        }        int index = hash(word);        // create new node if bucket is empty        if (buckets[index] == null) {            buckets[index] = new Node(word);            buckets[index].value.add(docId);            size++;            return;        }        // check if the word alr exists in the linked list        Node current = buckets[index];        while (current != null) {            // if word exists, add value to its list            if ((word == null && current.key == null) ||                    (word != null && word.equals(current.key))) {                if (!current.value.contains(docId)) {                    current.value.add(docId);                }                return;            }            if (current.next == null) {                break;            }            current = current.next;        }        // if no word, add new one to the end of the list        Node newNode = new Node(word);        newNode.value.add(docId);        current.next = newNode;        size++;    }    // return list of values where the word appears, and returns empty if it's not in the map    public List<Integer> getDocuments(String word) {        int index = hash(word);        Node current = buckets[index];        while (current != null) {            if ((word == null && current.key == null) ||                    (word != null && word.equals(current.key))) {                return new ArrayList<>(current.value);            }            current = current.next;        }        return new ArrayList<>();    }    // return all words    public List<String> getAllWords() {        List<String> words = new ArrayList<>();        for (Node bucket : buckets) {            Node current = bucket;            while (current != null) {                words.add(current.key);                current = current.next;            }        }        return words;    }    // resizing to twice its current size and re-hashing    @SuppressWarnings("unchecked")    private void resize() {        Node[] oldBuckets = buckets;        buckets = new Node[oldBuckets.length * 2];        size = 0;        // rehashing        for (Node bucket : oldBuckets) {            Node current = bucket;            while (current != null) {                List <Integer> value = current.value;                for (Integer ID : value) {                    addWordOccurrence(current.key, ID);                }                current = current.next;            }        }    }}